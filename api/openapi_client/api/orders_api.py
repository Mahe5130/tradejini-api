# coding: utf-8

"""
    CubePlus Rest API Specifications

    Gateway API's

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictBool, StrictFloat, StrictInt, StrictStr, field_validator

from typing import Optional, Union

from openapi_client.models.basket_order_margin_request import BasketOrderMarginRequest
from openapi_client.models.cancel_order200_response import CancelOrder200Response
from openapi_client.models.convert_position200_response import ConvertPosition200Response
from openapi_client.models.get_basket_order_margin200_response import GetBasketOrderMargin200Response
from openapi_client.models.get_holdings200_response import GetHoldings200Response
from openapi_client.models.get_order_history200_response import GetOrderHistory200Response
from openapi_client.models.get_order_margin200_response import GetOrderMargin200Response
from openapi_client.models.get_orders200_response import GetOrders200Response
from openapi_client.models.get_positions200_response import GetPositions200Response
from openapi_client.models.get_trades200_response import GetTrades200Response
from openapi_client.models.modify_order200_response import ModifyOrder200Response
from openapi_client.models.place_order200_response import PlaceOrder200Response

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class OrdersApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def cancel_order(
        self,
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs to be cancelled. Order id is received from orders response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CancelOrder200Response:
        """Cancel Order

        to cancel the pending order

        :param order_id: Order id of an order which needs to be cancelled. Order id is received from orders response (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_order_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelOrder200Response",
            '401': "CancelOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_order_with_http_info(
        self,
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs to be cancelled. Order id is received from orders response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CancelOrder200Response]:
        """Cancel Order

        to cancel the pending order

        :param order_id: Order id of an order which needs to be cancelled. Order id is received from orders response (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_order_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelOrder200Response",
            '401': "CancelOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_order_without_preload_content(
        self,
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs to be cancelled. Order id is received from orders response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel Order

        to cancel the pending order

        :param order_id: Order id of an order which needs to be cancelled. Order id is received from orders response (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_order_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelOrder200Response",
            '401': "CancelOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_order_serialize(
        self,
        order_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/oms/cancel-order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def convert_position(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        from_product: Annotated[StrictStr, Field(description="Current product type of a position record")],
        to_product: Annotated[StrictStr, Field(description="Product to which the user wants to convert ")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConvertPosition200Response:
        """Convert Position 

        to convert a position from one product type to another

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param from_product: Current product type of a position record (required)
        :type from_product: str
        :param to_product: Product to which the user wants to convert  (required)
        :type to_product: str
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._convert_position_serialize(
            sym_id=sym_id,
            qty=qty,
            from_product=from_product,
            to_product=to_product,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConvertPosition200Response",
            '401': "ConvertPositionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def convert_position_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        from_product: Annotated[StrictStr, Field(description="Current product type of a position record")],
        to_product: Annotated[StrictStr, Field(description="Product to which the user wants to convert ")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConvertPosition200Response]:
        """Convert Position 

        to convert a position from one product type to another

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param from_product: Current product type of a position record (required)
        :type from_product: str
        :param to_product: Product to which the user wants to convert  (required)
        :type to_product: str
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._convert_position_serialize(
            sym_id=sym_id,
            qty=qty,
            from_product=from_product,
            to_product=to_product,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConvertPosition200Response",
            '401': "ConvertPositionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def convert_position_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        from_product: Annotated[StrictStr, Field(description="Current product type of a position record")],
        to_product: Annotated[StrictStr, Field(description="Product to which the user wants to convert ")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Convert Position 

        to convert a position from one product type to another

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param from_product: Current product type of a position record (required)
        :type from_product: str
        :param to_product: Product to which the user wants to convert  (required)
        :type to_product: str
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._convert_position_serialize(
            sym_id=sym_id,
            qty=qty,
            from_product=from_product,
            to_product=to_product,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConvertPosition200Response",
            '401': "ConvertPositionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _convert_position_serialize(
        self,
        sym_id,
        qty,
        from_product,
        to_product,
        side,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if qty is not None:
            _form_params.append(('qty', qty))
        if from_product is not None:
            _form_params.append(('fromProduct', from_product))
        if to_product is not None:
            _form_params.append(('toProduct', to_product))
        if side is not None:
            _form_params.append(('side', side))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/convert-position',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_basket_order_margin(
        self,
        basket_order_margin_request: BasketOrderMarginRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetBasketOrderMargin200Response:
        """Basket Order Margin

        Basket order margin

        :param basket_order_margin_request: (required)
        :type basket_order_margin_request: BasketOrderMarginRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_basket_order_margin_serialize(
            basket_order_margin_request=basket_order_margin_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBasketOrderMargin200Response",
            '401': "BasketOrderMarginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_basket_order_margin_with_http_info(
        self,
        basket_order_margin_request: BasketOrderMarginRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetBasketOrderMargin200Response]:
        """Basket Order Margin

        Basket order margin

        :param basket_order_margin_request: (required)
        :type basket_order_margin_request: BasketOrderMarginRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_basket_order_margin_serialize(
            basket_order_margin_request=basket_order_margin_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBasketOrderMargin200Response",
            '401': "BasketOrderMarginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_basket_order_margin_without_preload_content(
        self,
        basket_order_margin_request: BasketOrderMarginRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Basket Order Margin

        Basket order margin

        :param basket_order_margin_request: (required)
        :type basket_order_margin_request: BasketOrderMarginRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_basket_order_margin_serialize(
            basket_order_margin_request=basket_order_margin_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBasketOrderMargin200Response",
            '401': "BasketOrderMarginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_basket_order_margin_serialize(
        self,
        basket_order_margin_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if basket_order_margin_request is not None:
            _body_params = basket_order_margin_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/basket-margin',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_holdings(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetHoldings200Response:
        """Holdings 

        to get the list of holding records

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_holdings_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetHoldings200Response",
            '401': "HoldingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_holdings_with_http_info(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetHoldings200Response]:
        """Holdings 

        to get the list of holding records

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_holdings_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetHoldings200Response",
            '401': "HoldingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_holdings_without_preload_content(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Holdings 

        to get the list of holding records

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_holdings_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetHoldings200Response",
            '401': "HoldingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_holdings_serialize(
        self,
        sym_details,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sym_details is not None:
            
            _query_params.append(('symDetails', sym_details))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/oms/holdings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_order_history(
        self,
        order_id: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOrderHistory200Response:
        """History

        to get an order history of an order

        :param order_id: Order id of an order. This will be received in orders response (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_history_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderHistory200Response",
            '401': "OrderHistoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_order_history_with_http_info(
        self,
        order_id: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOrderHistory200Response]:
        """History

        to get an order history of an order

        :param order_id: Order id of an order. This will be received in orders response (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_history_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderHistory200Response",
            '401': "OrderHistoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_order_history_without_preload_content(
        self,
        order_id: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """History

        to get an order history of an order

        :param order_id: Order id of an order. This will be received in orders response (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_history_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderHistory200Response",
            '401': "OrderHistoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_order_history_serialize(
        self,
        order_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/oms/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_order_margin(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="'qty' is number of shares for which required margin, for modification order 'qty' should be 'fillQty' + 'modified qty' ")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        stop_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Stop loss leg order trigger price.")] = None,
        org_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original quantity is applicable for modification order, original quantity is 'qty' from orderbook")] = None,
        org_limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original limit price is applicable for modification order, original limit price is limit price from orderbook")] = None,
        org_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook")] = None,
        org_stop_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.")] = None,
        fill_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="fillQty is partially filled quantity, fillQty is 'fillQty' from orderbook.")] = None,
        order_id: Annotated[Optional[StrictStr], Field(description="Order id is applicable for bracket and cover order modification ")] = None,
        main_leg_order_id: Annotated[Optional[StrictStr], Field(description="Mainleg order id field is applicable for bracket and cover order")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOrderMargin200Response:
        """Order Margin

        to get the margin required and available margin info while placing an order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: 'qty' is number of shares for which required margin, for modification order 'qty' should be 'fillQty' + 'modified qty'  (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param stop_trig_price: Stop loss leg order trigger price.
        :type stop_trig_price: float
        :param org_qty: Original quantity is applicable for modification order, original quantity is 'qty' from orderbook
        :type org_qty: float
        :param org_limit_price: Original limit price is applicable for modification order, original limit price is limit price from orderbook
        :type org_limit_price: float
        :param org_trig_price: Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook
        :type org_trig_price: float
        :param org_stop_trig_price: Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.
        :type org_stop_trig_price: float
        :param fill_qty: fillQty is partially filled quantity, fillQty is 'fillQty' from orderbook.
        :type fill_qty: float
        :param order_id: Order id is applicable for bracket and cover order modification 
        :type order_id: str
        :param main_leg_order_id: Mainleg order id field is applicable for bracket and cover order
        :type main_leg_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_margin_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            product=product,
            limit_price=limit_price,
            trig_price=trig_price,
            stop_trig_price=stop_trig_price,
            org_qty=org_qty,
            org_limit_price=org_limit_price,
            org_trig_price=org_trig_price,
            org_stop_trig_price=org_stop_trig_price,
            fill_qty=fill_qty,
            order_id=order_id,
            main_leg_order_id=main_leg_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderMargin200Response",
            '400': "OrderMarginResponse",
            '401': "OrderMarginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_order_margin_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="'qty' is number of shares for which required margin, for modification order 'qty' should be 'fillQty' + 'modified qty' ")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        stop_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Stop loss leg order trigger price.")] = None,
        org_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original quantity is applicable for modification order, original quantity is 'qty' from orderbook")] = None,
        org_limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original limit price is applicable for modification order, original limit price is limit price from orderbook")] = None,
        org_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook")] = None,
        org_stop_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.")] = None,
        fill_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="fillQty is partially filled quantity, fillQty is 'fillQty' from orderbook.")] = None,
        order_id: Annotated[Optional[StrictStr], Field(description="Order id is applicable for bracket and cover order modification ")] = None,
        main_leg_order_id: Annotated[Optional[StrictStr], Field(description="Mainleg order id field is applicable for bracket and cover order")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOrderMargin200Response]:
        """Order Margin

        to get the margin required and available margin info while placing an order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: 'qty' is number of shares for which required margin, for modification order 'qty' should be 'fillQty' + 'modified qty'  (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param stop_trig_price: Stop loss leg order trigger price.
        :type stop_trig_price: float
        :param org_qty: Original quantity is applicable for modification order, original quantity is 'qty' from orderbook
        :type org_qty: float
        :param org_limit_price: Original limit price is applicable for modification order, original limit price is limit price from orderbook
        :type org_limit_price: float
        :param org_trig_price: Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook
        :type org_trig_price: float
        :param org_stop_trig_price: Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.
        :type org_stop_trig_price: float
        :param fill_qty: fillQty is partially filled quantity, fillQty is 'fillQty' from orderbook.
        :type fill_qty: float
        :param order_id: Order id is applicable for bracket and cover order modification 
        :type order_id: str
        :param main_leg_order_id: Mainleg order id field is applicable for bracket and cover order
        :type main_leg_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_margin_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            product=product,
            limit_price=limit_price,
            trig_price=trig_price,
            stop_trig_price=stop_trig_price,
            org_qty=org_qty,
            org_limit_price=org_limit_price,
            org_trig_price=org_trig_price,
            org_stop_trig_price=org_stop_trig_price,
            fill_qty=fill_qty,
            order_id=order_id,
            main_leg_order_id=main_leg_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderMargin200Response",
            '400': "OrderMarginResponse",
            '401': "OrderMarginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_order_margin_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="'qty' is number of shares for which required margin, for modification order 'qty' should be 'fillQty' + 'modified qty' ")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        stop_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Stop loss leg order trigger price.")] = None,
        org_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original quantity is applicable for modification order, original quantity is 'qty' from orderbook")] = None,
        org_limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original limit price is applicable for modification order, original limit price is limit price from orderbook")] = None,
        org_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook")] = None,
        org_stop_trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.")] = None,
        fill_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="fillQty is partially filled quantity, fillQty is 'fillQty' from orderbook.")] = None,
        order_id: Annotated[Optional[StrictStr], Field(description="Order id is applicable for bracket and cover order modification ")] = None,
        main_leg_order_id: Annotated[Optional[StrictStr], Field(description="Mainleg order id field is applicable for bracket and cover order")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Order Margin

        to get the margin required and available margin info while placing an order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: 'qty' is number of shares for which required margin, for modification order 'qty' should be 'fillQty' + 'modified qty'  (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param stop_trig_price: Stop loss leg order trigger price.
        :type stop_trig_price: float
        :param org_qty: Original quantity is applicable for modification order, original quantity is 'qty' from orderbook
        :type org_qty: float
        :param org_limit_price: Original limit price is applicable for modification order, original limit price is limit price from orderbook
        :type org_limit_price: float
        :param org_trig_price: Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook
        :type org_trig_price: float
        :param org_stop_trig_price: Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.
        :type org_stop_trig_price: float
        :param fill_qty: fillQty is partially filled quantity, fillQty is 'fillQty' from orderbook.
        :type fill_qty: float
        :param order_id: Order id is applicable for bracket and cover order modification 
        :type order_id: str
        :param main_leg_order_id: Mainleg order id field is applicable for bracket and cover order
        :type main_leg_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_margin_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            product=product,
            limit_price=limit_price,
            trig_price=trig_price,
            stop_trig_price=stop_trig_price,
            org_qty=org_qty,
            org_limit_price=org_limit_price,
            org_trig_price=org_trig_price,
            org_stop_trig_price=org_stop_trig_price,
            fill_qty=fill_qty,
            order_id=order_id,
            main_leg_order_id=main_leg_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrderMargin200Response",
            '400': "OrderMarginResponse",
            '401': "OrderMarginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_order_margin_serialize(
        self,
        sym_id,
        qty,
        side,
        type,
        product,
        limit_price,
        trig_price,
        stop_trig_price,
        org_qty,
        org_limit_price,
        org_trig_price,
        org_stop_trig_price,
        fill_qty,
        order_id,
        main_leg_order_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if qty is not None:
            _form_params.append(('qty', qty))
        if side is not None:
            _form_params.append(('side', side))
        if type is not None:
            _form_params.append(('type', type))
        if product is not None:
            _form_params.append(('product', product))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if stop_trig_price is not None:
            _form_params.append(('stopTrigPrice', stop_trig_price))
        if org_qty is not None:
            _form_params.append(('orgQty', org_qty))
        if org_limit_price is not None:
            _form_params.append(('orgLimitPrice', org_limit_price))
        if org_trig_price is not None:
            _form_params.append(('orgTrigPrice', org_trig_price))
        if org_stop_trig_price is not None:
            _form_params.append(('orgStopTrigPrice', org_stop_trig_price))
        if fill_qty is not None:
            _form_params.append(('fillQty', fill_qty))
        if order_id is not None:
            _form_params.append(('orderId', order_id))
        if main_leg_order_id is not None:
            _form_params.append(('mainLegOrderId', main_leg_order_id))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/margin',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_orders(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOrders200Response:
        """Orders

        to get list of orders placed

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_orders_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrders200Response",
            '401': "OrdersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_orders_with_http_info(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOrders200Response]:
        """Orders

        to get list of orders placed

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_orders_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrders200Response",
            '401': "OrdersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_orders_without_preload_content(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Orders

        to get list of orders placed

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_orders_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetOrders200Response",
            '401': "OrdersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_orders_serialize(
        self,
        sym_details,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sym_details is not None:
            
            _query_params.append(('symDetails', sym_details))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/oms/orders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_positions(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetPositions200Response:
        """Positions 

        to get a list of positions records </br></br> <b>MTM Calculations:</b> <ul> <li><b>Realized:</b> realizedPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netAvgPrice)) * multiplier * pricefactor</li> <li><b>Total MTM:</b> Realized + UnRealized</li> </ul> <b>P&L Calculations:</b> <ul> <li><b>Realized:</b> realizedOrgPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netOrgAvgPrice)) * multiplier * pricefactor</li> <li><b>Total P&L:</b> Realized + UnRealized</li> </ul> <b>Day Positions - MTM Calculations:</b> <ul> <li><b>Realized:</b> dayRealizedPnl</li> <li><b>UnRealized:</b> ( dayQty * ( LTP - dayAvg)) * multiplier * pricefactor</li> <li><b>Total Day MTM:</b> Realized + UnRealized</li> </ul> <b>Note:</b> <ul> <li>For the commodity (MCX), the net quantity should be multiplied by the lot size in the above calculations.</li> <li>The LTP mentioned above should be retrieved from real-time updates via the streaming SDK</li> </ul>

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_positions_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPositions200Response",
            '401': "PositionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_positions_with_http_info(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetPositions200Response]:
        """Positions 

        to get a list of positions records </br></br> <b>MTM Calculations:</b> <ul> <li><b>Realized:</b> realizedPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netAvgPrice)) * multiplier * pricefactor</li> <li><b>Total MTM:</b> Realized + UnRealized</li> </ul> <b>P&L Calculations:</b> <ul> <li><b>Realized:</b> realizedOrgPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netOrgAvgPrice)) * multiplier * pricefactor</li> <li><b>Total P&L:</b> Realized + UnRealized</li> </ul> <b>Day Positions - MTM Calculations:</b> <ul> <li><b>Realized:</b> dayRealizedPnl</li> <li><b>UnRealized:</b> ( dayQty * ( LTP - dayAvg)) * multiplier * pricefactor</li> <li><b>Total Day MTM:</b> Realized + UnRealized</li> </ul> <b>Note:</b> <ul> <li>For the commodity (MCX), the net quantity should be multiplied by the lot size in the above calculations.</li> <li>The LTP mentioned above should be retrieved from real-time updates via the streaming SDK</li> </ul>

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_positions_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPositions200Response",
            '401': "PositionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_positions_without_preload_content(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Positions 

        to get a list of positions records </br></br> <b>MTM Calculations:</b> <ul> <li><b>Realized:</b> realizedPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netAvgPrice)) * multiplier * pricefactor</li> <li><b>Total MTM:</b> Realized + UnRealized</li> </ul> <b>P&L Calculations:</b> <ul> <li><b>Realized:</b> realizedOrgPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netOrgAvgPrice)) * multiplier * pricefactor</li> <li><b>Total P&L:</b> Realized + UnRealized</li> </ul> <b>Day Positions - MTM Calculations:</b> <ul> <li><b>Realized:</b> dayRealizedPnl</li> <li><b>UnRealized:</b> ( dayQty * ( LTP - dayAvg)) * multiplier * pricefactor</li> <li><b>Total Day MTM:</b> Realized + UnRealized</li> </ul> <b>Note:</b> <ul> <li>For the commodity (MCX), the net quantity should be multiplied by the lot size in the above calculations.</li> <li>The LTP mentioned above should be retrieved from real-time updates via the streaming SDK</li> </ul>

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_positions_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPositions200Response",
            '401': "PositionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_positions_serialize(
        self,
        sym_details,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sym_details is not None:
            
            _query_params.append(('symDetails', sym_details))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/oms/positions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_trades(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetTrades200Response:
        """Trades

        to get a list of trade records

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trades_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTrades200Response",
            '401': "TradesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_trades_with_http_info(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetTrades200Response]:
        """Trades

        to get a list of trade records

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trades_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTrades200Response",
            '401': "TradesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_trades_without_preload_content(
        self,
        sym_details: Annotated[Optional[StrictBool], Field(description="Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Trades

        to get a list of trade records

        :param sym_details: Sending symDetails:'true' - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
        :type sym_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trades_serialize(
            sym_details=sym_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTrades200Response",
            '401': "TradesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_trades_serialize(
        self,
        sym_details,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sym_details is not None:
            
            _query_params.append(('symDetails', sym_details))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/oms/trades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def modify_order(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        validity: Annotated[StrictStr, Field(description="Validity of an order, EOS is applicable for BSE scrips only")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        disc_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Disclosed quantity of an order")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Market order protection percentage. Applicable only for market orders")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModifyOrder200Response:
        """Modify Order

        to modify the pending order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param validity: Validity of an order, EOS is applicable for BSE scrips only (required)
        :type validity: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param disc_qty: Disclosed quantity of an order
        :type disc_qty: float
        :param mkt_prot: Market order protection percentage. Applicable only for market orders
        :type mkt_prot: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            validity=validity,
            limit_price=limit_price,
            trig_price=trig_price,
            disc_qty=disc_qty,
            mkt_prot=mkt_prot,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def modify_order_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        validity: Annotated[StrictStr, Field(description="Validity of an order, EOS is applicable for BSE scrips only")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        disc_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Disclosed quantity of an order")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Market order protection percentage. Applicable only for market orders")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModifyOrder200Response]:
        """Modify Order

        to modify the pending order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param validity: Validity of an order, EOS is applicable for BSE scrips only (required)
        :type validity: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param disc_qty: Disclosed quantity of an order
        :type disc_qty: float
        :param mkt_prot: Market order protection percentage. Applicable only for market orders
        :type mkt_prot: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            validity=validity,
            limit_price=limit_price,
            trig_price=trig_price,
            disc_qty=disc_qty,
            mkt_prot=mkt_prot,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def modify_order_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        validity: Annotated[StrictStr, Field(description="Validity of an order, EOS is applicable for BSE scrips only")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        disc_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Disclosed quantity of an order")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Market order protection percentage. Applicable only for market orders")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Modify Order

        to modify the pending order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param validity: Validity of an order, EOS is applicable for BSE scrips only (required)
        :type validity: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param disc_qty: Disclosed quantity of an order
        :type disc_qty: float
        :param mkt_prot: Market order protection percentage. Applicable only for market orders
        :type mkt_prot: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            validity=validity,
            limit_price=limit_price,
            trig_price=trig_price,
            disc_qty=disc_qty,
            mkt_prot=mkt_prot,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _modify_order_serialize(
        self,
        sym_id,
        order_id,
        qty,
        type,
        validity,
        limit_price,
        trig_price,
        disc_qty,
        mkt_prot,
        side,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if order_id is not None:
            _form_params.append(('orderId', order_id))
        if qty is not None:
            _form_params.append(('qty', qty))
        if type is not None:
            _form_params.append(('type', type))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if validity is not None:
            _form_params.append(('validity', validity))
        if disc_qty is not None:
            _form_params.append(('discQty', disc_qty))
        if mkt_prot is not None:
            _form_params.append(('mktProt', mkt_prot))
        if side is not None:
            _form_params.append(('side', side))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/oms/modify-order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place_order(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        validity: Annotated[StrictStr, Field(description="Validity of an order, EOS is applicable for BSE scrips only")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        disc_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Disclosed quantity of an order")] = None,
        amo: Annotated[Optional[StrictBool], Field(description="Pass this field as true to place an amo order.")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Market order protection percentage. Applicable only for market orders")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlaceOrder200Response:
        """Place Order

        to place the order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param validity: Validity of an order, EOS is applicable for BSE scrips only (required)
        :type validity: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param disc_qty: Disclosed quantity of an order
        :type disc_qty: float
        :param amo: Pass this field as true to place an amo order.
        :type amo: bool
        :param mkt_prot: Market order protection percentage. Applicable only for market orders
        :type mkt_prot: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            product=product,
            validity=validity,
            limit_price=limit_price,
            trig_price=trig_price,
            disc_qty=disc_qty,
            amo=amo,
            mkt_prot=mkt_prot,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_order_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        validity: Annotated[StrictStr, Field(description="Validity of an order, EOS is applicable for BSE scrips only")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        disc_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Disclosed quantity of an order")] = None,
        amo: Annotated[Optional[StrictBool], Field(description="Pass this field as true to place an amo order.")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Market order protection percentage. Applicable only for market orders")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlaceOrder200Response]:
        """Place Order

        to place the order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param validity: Validity of an order, EOS is applicable for BSE scrips only (required)
        :type validity: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param disc_qty: Disclosed quantity of an order
        :type disc_qty: float
        :param amo: Pass this field as true to place an amo order.
        :type amo: bool
        :param mkt_prot: Market order protection percentage. Applicable only for market orders
        :type mkt_prot: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            product=product,
            validity=validity,
            limit_price=limit_price,
            trig_price=trig_price,
            disc_qty=disc_qty,
            amo=amo,
            mkt_prot=mkt_prot,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_order_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        validity: Annotated[StrictStr, Field(description="Validity of an order, EOS is applicable for BSE scrips only")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for stoploss limit and stoploss market orders")] = None,
        disc_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Disclosed quantity of an order")] = None,
        amo: Annotated[Optional[StrictBool], Field(description="Pass this field as true to place an amo order.")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Market order protection percentage. Applicable only for market orders")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Place Order

        to place the order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param validity: Validity of an order, EOS is applicable for BSE scrips only (required)
        :type validity: str
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param trig_price: This is required only for stoploss limit and stoploss market orders
        :type trig_price: float
        :param disc_qty: Disclosed quantity of an order
        :type disc_qty: float
        :param amo: Pass this field as true to place an amo order.
        :type amo: bool
        :param mkt_prot: Market order protection percentage. Applicable only for market orders
        :type mkt_prot: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            product=product,
            validity=validity,
            limit_price=limit_price,
            trig_price=trig_price,
            disc_qty=disc_qty,
            amo=amo,
            mkt_prot=mkt_prot,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_order_serialize(
        self,
        sym_id,
        qty,
        side,
        type,
        product,
        validity,
        limit_price,
        trig_price,
        disc_qty,
        amo,
        mkt_prot,
        remarks,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if qty is not None:
            _form_params.append(('qty', qty))
        if side is not None:
            _form_params.append(('side', side))
        if type is not None:
            _form_params.append(('type', type))
        if product is not None:
            _form_params.append(('product', product))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if validity is not None:
            _form_params.append(('validity', validity))
        if disc_qty is not None:
            _form_params.append(('discQty', disc_qty))
        if amo is not None:
            _form_params.append(('amo', amo))
        if mkt_prot is not None:
            _form_params.append(('mktProt', mkt_prot))
        if remarks is not None:
            _form_params.append(('remarks', remarks))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/place-order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


