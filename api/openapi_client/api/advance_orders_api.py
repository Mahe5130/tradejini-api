# coding: utf-8

"""
    CubePlus Rest API Specifications

    Gateway API's

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictFloat, StrictInt, StrictStr, field_validator

from typing import Optional, Union

from openapi_client.models.cancel_gtt_order200_response import CancelGTTOrder200Response
from openapi_client.models.cancel_oco_order200_response import CancelOCOOrder200Response
from openapi_client.models.exit_order200_response import ExitOrder200Response
from openapi_client.models.modify_gtt_order200_response import ModifyGTTOrder200Response
from openapi_client.models.modify_oco_order200_response import ModifyOCOOrder200Response
from openapi_client.models.modify_order200_response import ModifyOrder200Response
from openapi_client.models.pending_gtt_orders200_response import PendingGTTOrders200Response
from openapi_client.models.place_bracket_order200_response import PlaceBracketOrder200Response
from openapi_client.models.place_gtt_order200_response import PlaceGTTOrder200Response
from openapi_client.models.place_oco_order200_response import PlaceOCOOrder200Response

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AdvanceOrdersApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def cancel_gtt_order(
        self,
        order_no: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CancelGTTOrder200Response:
        """Cancel GTT Order

        to cancel the GTT order

        :param order_no: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_gtt_order_serialize(
            order_no=order_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelGTTOrder200Response",
            '401': "CancelGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_gtt_order_with_http_info(
        self,
        order_no: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CancelGTTOrder200Response]:
        """Cancel GTT Order

        to cancel the GTT order

        :param order_no: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_gtt_order_serialize(
            order_no=order_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelGTTOrder200Response",
            '401': "CancelGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_gtt_order_without_preload_content(
        self,
        order_no: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel GTT Order

        to cancel the GTT order

        :param order_no: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_gtt_order_serialize(
            order_no=order_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelGTTOrder200Response",
            '401': "CancelGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_gtt_order_serialize(
        self,
        order_no,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if order_no is not None:
            
            _query_params.append(('orderNo', order_no))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/oms/cancel-order/gtt',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cancel_oco_order(
        self,
        order_no: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CancelOCOOrder200Response:
        """Cancel OCO Order

        Cancel A one-cancels-the-other order

        :param order_no: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_oco_order_serialize(
            order_no=order_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelOCOOrder200Response",
            '401': "CancelOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_oco_order_with_http_info(
        self,
        order_no: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CancelOCOOrder200Response]:
        """Cancel OCO Order

        Cancel A one-cancels-the-other order

        :param order_no: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_oco_order_serialize(
            order_no=order_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelOCOOrder200Response",
            '401': "CancelOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_oco_order_without_preload_content(
        self,
        order_no: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel OCO Order

        Cancel A one-cancels-the-other order

        :param order_no: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_oco_order_serialize(
            order_no=order_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelOCOOrder200Response",
            '401': "CancelOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_oco_order_serialize(
        self,
        order_no,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if order_no is not None:
            
            _query_params.append(('orderNo', order_no))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/oms/cancel-order/oco',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def exit_order(
        self,
        order_id: Annotated[StrictStr, Field(description="Main leg order id of bracker or cover order should be passed here. It will be received from the field 'mainLegOrderId' in orders response")],
        product: Annotated[StrictStr, Field(description="Pass the respective product type bracket or cover here to exit")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExitOrder200Response:
        """Exit Order

        to exit bracket or cover order.

        :param order_id: Main leg order id of bracker or cover order should be passed here. It will be received from the field 'mainLegOrderId' in orders response (required)
        :type order_id: str
        :param product: Pass the respective product type bracket or cover here to exit (required)
        :type product: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exit_order_serialize(
            order_id=order_id,
            product=product,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExitOrder200Response",
            '400': "ExitOrderResponse",
            '401': "ExitOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def exit_order_with_http_info(
        self,
        order_id: Annotated[StrictStr, Field(description="Main leg order id of bracker or cover order should be passed here. It will be received from the field 'mainLegOrderId' in orders response")],
        product: Annotated[StrictStr, Field(description="Pass the respective product type bracket or cover here to exit")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExitOrder200Response]:
        """Exit Order

        to exit bracket or cover order.

        :param order_id: Main leg order id of bracker or cover order should be passed here. It will be received from the field 'mainLegOrderId' in orders response (required)
        :type order_id: str
        :param product: Pass the respective product type bracket or cover here to exit (required)
        :type product: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exit_order_serialize(
            order_id=order_id,
            product=product,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExitOrder200Response",
            '400': "ExitOrderResponse",
            '401': "ExitOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def exit_order_without_preload_content(
        self,
        order_id: Annotated[StrictStr, Field(description="Main leg order id of bracker or cover order should be passed here. It will be received from the field 'mainLegOrderId' in orders response")],
        product: Annotated[StrictStr, Field(description="Pass the respective product type bracket or cover here to exit")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Exit Order

        to exit bracket or cover order.

        :param order_id: Main leg order id of bracker or cover order should be passed here. It will be received from the field 'mainLegOrderId' in orders response (required)
        :type order_id: str
        :param product: Pass the respective product type bracket or cover here to exit (required)
        :type product: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exit_order_serialize(
            order_id=order_id,
            product=product,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExitOrder200Response",
            '400': "ExitOrderResponse",
            '401': "ExitOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _exit_order_serialize(
        self,
        order_id,
        product,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if order_id is not None:
            _form_params.append(('orderId', order_id))
        if product is not None:
            _form_params.append(('product', product))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/exit-order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def modify_bracket_order(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        target_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        trailing_stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Trailing stop loss price.")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModifyOrder200Response:
        """Modify Bracket Order

        to modify the bracket order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param target_price: Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field (required)
        :type target_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param trailing_stop_price: Trailing stop loss price.
        :type trailing_stop_price: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_bracket_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            stop_trig_price=stop_trig_price,
            target_price=target_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            trailing_stop_price=trailing_stop_price,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def modify_bracket_order_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        target_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        trailing_stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Trailing stop loss price.")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModifyOrder200Response]:
        """Modify Bracket Order

        to modify the bracket order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param target_price: Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field (required)
        :type target_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param trailing_stop_price: Trailing stop loss price.
        :type trailing_stop_price: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_bracket_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            stop_trig_price=stop_trig_price,
            target_price=target_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            trailing_stop_price=trailing_stop_price,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def modify_bracket_order_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        target_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        trailing_stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Trailing stop loss price.")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Modify Bracket Order

        to modify the bracket order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param target_price: Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field (required)
        :type target_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param trailing_stop_price: Trailing stop loss price.
        :type trailing_stop_price: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_bracket_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            stop_trig_price=stop_trig_price,
            target_price=target_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            trailing_stop_price=trailing_stop_price,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _modify_bracket_order_serialize(
        self,
        sym_id,
        order_id,
        qty,
        type,
        stop_trig_price,
        target_price,
        limit_price,
        trig_price,
        mkt_prot,
        trailing_stop_price,
        side,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if order_id is not None:
            _form_params.append(('orderId', order_id))
        if qty is not None:
            _form_params.append(('qty', qty))
        if type is not None:
            _form_params.append(('type', type))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if mkt_prot is not None:
            _form_params.append(('mktProt', mkt_prot))
        if stop_trig_price is not None:
            _form_params.append(('stopTrigPrice', stop_trig_price))
        if target_price is not None:
            _form_params.append(('targetPrice', target_price))
        if trailing_stop_price is not None:
            _form_params.append(('trailingStopPrice', trailing_stop_price))
        if side is not None:
            _form_params.append(('side', side))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/oms/modify-order/bo',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def modify_cover_order(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModifyOrder200Response:
        """Modify Cover Order

        to modify the cover order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_cover_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            stop_trig_price=stop_trig_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def modify_cover_order_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModifyOrder200Response]:
        """Modify Cover Order

        to modify the cover order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_cover_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            stop_trig_price=stop_trig_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def modify_cover_order_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        order_id: Annotated[StrictStr, Field(description="Order id of an order which needs modification. This id will be received in orders service")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent. ")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        side: Annotated[Optional[StrictStr], Field(description="Order side 'buy' or 'sell'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Modify Cover Order

        to modify the cover order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param order_id: Order id of an order which needs modification. This id will be received in orders service (required)
        :type order_id: str
        :param qty: Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty => (60 + 70) = 130 should be sent.  (required)
        :type qty: float
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param side: Order side 'buy' or 'sell'
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_cover_order_serialize(
            sym_id=sym_id,
            order_id=order_id,
            qty=qty,
            type=type,
            stop_trig_price=stop_trig_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOrder200Response",
            '400': "ModifyOrderResponse",
            '401': "ModifyOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _modify_cover_order_serialize(
        self,
        sym_id,
        order_id,
        qty,
        type,
        stop_trig_price,
        limit_price,
        trig_price,
        mkt_prot,
        side,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if order_id is not None:
            _form_params.append(('orderId', order_id))
        if qty is not None:
            _form_params.append(('qty', qty))
        if type is not None:
            _form_params.append(('type', type))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if mkt_prot is not None:
            _form_params.append(('mktProt', mkt_prot))
        if side is not None:
            _form_params.append(('side', side))
        if stop_trig_price is not None:
            _form_params.append(('stopTrigPrice', stop_trig_price))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/oms/modify-order/co',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def modify_gtt_order(
        self,
        order_id: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        trig_price_per: Annotated[Union[StrictFloat, StrictInt], Field(description="Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.")],
        trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModifyGTTOrder200Response:
        """Modify GTT Order

        Modify good till triggered order

        :param order_id: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_id: str
        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param trig_price_per: Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP. (required)
        :type trig_price_per: float
        :param trig_price: Trigger price with respect to LTP (required)
        :type trig_price: float
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_gtt_order_serialize(
            order_id=order_id,
            sym_id=sym_id,
            side=side,
            type=type,
            product=product,
            trig_price_per=trig_price_per,
            trig_price=trig_price,
            qty=qty,
            limit_price=limit_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyGTTOrder200Response",
            '401': "ModifyGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def modify_gtt_order_with_http_info(
        self,
        order_id: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        trig_price_per: Annotated[Union[StrictFloat, StrictInt], Field(description="Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.")],
        trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModifyGTTOrder200Response]:
        """Modify GTT Order

        Modify good till triggered order

        :param order_id: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_id: str
        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param trig_price_per: Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP. (required)
        :type trig_price_per: float
        :param trig_price: Trigger price with respect to LTP (required)
        :type trig_price: float
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_gtt_order_serialize(
            order_id=order_id,
            sym_id=sym_id,
            side=side,
            type=type,
            product=product,
            trig_price_per=trig_price_per,
            trig_price=trig_price,
            qty=qty,
            limit_price=limit_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyGTTOrder200Response",
            '401': "ModifyGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def modify_gtt_order_without_preload_content(
        self,
        order_id: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        trig_price_per: Annotated[Union[StrictFloat, StrictInt], Field(description="Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.")],
        trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Modify GTT Order

        Modify good till triggered order

        :param order_id: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_id: str
        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param trig_price_per: Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP. (required)
        :type trig_price_per: float
        :param trig_price: Trigger price with respect to LTP (required)
        :type trig_price: float
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_gtt_order_serialize(
            order_id=order_id,
            sym_id=sym_id,
            side=side,
            type=type,
            product=product,
            trig_price_per=trig_price_per,
            trig_price=trig_price,
            qty=qty,
            limit_price=limit_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyGTTOrder200Response",
            '401': "ModifyGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _modify_gtt_order_serialize(
        self,
        order_id,
        sym_id,
        side,
        type,
        product,
        trig_price_per,
        trig_price,
        qty,
        limit_price,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if order_id is not None:
            _form_params.append(('orderId', order_id))
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if side is not None:
            _form_params.append(('side', side))
        if type is not None:
            _form_params.append(('type', type))
        if product is not None:
            _form_params.append(('product', product))
        if trig_price_per is not None:
            _form_params.append(('trigPricePer', trig_price_per))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if qty is not None:
            _form_params.append(('qty', qty))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/oms/modify-order/gtt',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def modify_oco_order(
        self,
        order_id: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        stop_loss_type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_loss_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stoploss trigger price")],
        stop_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        target_type: Annotated[StrictStr, Field(description="Price type of an order")],
        target_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        target_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target trigger price")],
        target_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        target_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModifyOCOOrder200Response:
        """Modify OCO Order

        Modify one-cancels-the-other order

        :param order_id: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_id: str
        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param stop_loss_type: Price type of an order (required)
        :type stop_loss_type: str
        :param stop_loss_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type stop_loss_product: str
        :param stop_trig_price: Stoploss trigger price (required)
        :type stop_trig_price: float
        :param stop_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type stop_qty: float
        :param target_type: Price type of an order (required)
        :type target_type: str
        :param target_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type target_product: str
        :param target_trig_price: Target trigger price (required)
        :type target_trig_price: float
        :param target_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type target_qty: float
        :param stop_price: This is required only for limit and stop limit orders
        :type stop_price: float
        :param target_price: This is required only for limit and stop limit orders
        :type target_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_oco_order_serialize(
            order_id=order_id,
            sym_id=sym_id,
            side=side,
            stop_loss_type=stop_loss_type,
            stop_loss_product=stop_loss_product,
            stop_trig_price=stop_trig_price,
            stop_qty=stop_qty,
            target_type=target_type,
            target_product=target_product,
            target_trig_price=target_trig_price,
            target_qty=target_qty,
            stop_price=stop_price,
            target_price=target_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOCOOrder200Response",
            '401': "ModifyOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def modify_oco_order_with_http_info(
        self,
        order_id: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        stop_loss_type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_loss_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stoploss trigger price")],
        stop_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        target_type: Annotated[StrictStr, Field(description="Price type of an order")],
        target_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        target_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target trigger price")],
        target_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        target_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModifyOCOOrder200Response]:
        """Modify OCO Order

        Modify one-cancels-the-other order

        :param order_id: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_id: str
        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param stop_loss_type: Price type of an order (required)
        :type stop_loss_type: str
        :param stop_loss_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type stop_loss_product: str
        :param stop_trig_price: Stoploss trigger price (required)
        :type stop_trig_price: float
        :param stop_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type stop_qty: float
        :param target_type: Price type of an order (required)
        :type target_type: str
        :param target_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type target_product: str
        :param target_trig_price: Target trigger price (required)
        :type target_trig_price: float
        :param target_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type target_qty: float
        :param stop_price: This is required only for limit and stop limit orders
        :type stop_price: float
        :param target_price: This is required only for limit and stop limit orders
        :type target_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_oco_order_serialize(
            order_id=order_id,
            sym_id=sym_id,
            side=side,
            stop_loss_type=stop_loss_type,
            stop_loss_product=stop_loss_product,
            stop_trig_price=stop_trig_price,
            stop_qty=stop_qty,
            target_type=target_type,
            target_product=target_product,
            target_trig_price=target_trig_price,
            target_qty=target_qty,
            stop_price=stop_price,
            target_price=target_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOCOOrder200Response",
            '401': "ModifyOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def modify_oco_order_without_preload_content(
        self,
        order_id: Annotated[StrictStr, Field(description="Order Number is unique number which will be utilized while modifying and cancelling order")],
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        stop_loss_type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_loss_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stoploss trigger price")],
        stop_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        target_type: Annotated[StrictStr, Field(description="Price type of an order")],
        target_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        target_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target trigger price")],
        target_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        target_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Modify OCO Order

        Modify one-cancels-the-other order

        :param order_id: Order Number is unique number which will be utilized while modifying and cancelling order (required)
        :type order_id: str
        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param stop_loss_type: Price type of an order (required)
        :type stop_loss_type: str
        :param stop_loss_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type stop_loss_product: str
        :param stop_trig_price: Stoploss trigger price (required)
        :type stop_trig_price: float
        :param stop_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type stop_qty: float
        :param target_type: Price type of an order (required)
        :type target_type: str
        :param target_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type target_product: str
        :param target_trig_price: Target trigger price (required)
        :type target_trig_price: float
        :param target_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type target_qty: float
        :param stop_price: This is required only for limit and stop limit orders
        :type stop_price: float
        :param target_price: This is required only for limit and stop limit orders
        :type target_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._modify_oco_order_serialize(
            order_id=order_id,
            sym_id=sym_id,
            side=side,
            stop_loss_type=stop_loss_type,
            stop_loss_product=stop_loss_product,
            stop_trig_price=stop_trig_price,
            stop_qty=stop_qty,
            target_type=target_type,
            target_product=target_product,
            target_trig_price=target_trig_price,
            target_qty=target_qty,
            stop_price=stop_price,
            target_price=target_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyOCOOrder200Response",
            '401': "ModifyOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _modify_oco_order_serialize(
        self,
        order_id,
        sym_id,
        side,
        stop_loss_type,
        stop_loss_product,
        stop_trig_price,
        stop_qty,
        target_type,
        target_product,
        target_trig_price,
        target_qty,
        stop_price,
        target_price,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if order_id is not None:
            _form_params.append(('orderId', order_id))
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if side is not None:
            _form_params.append(('side', side))
        if stop_loss_type is not None:
            _form_params.append(('stopLossType', stop_loss_type))
        if stop_loss_product is not None:
            _form_params.append(('stopLossProduct', stop_loss_product))
        if stop_trig_price is not None:
            _form_params.append(('stopTrigPrice', stop_trig_price))
        if stop_qty is not None:
            _form_params.append(('stopQty', stop_qty))
        if stop_price is not None:
            _form_params.append(('stopPrice', stop_price))
        if target_type is not None:
            _form_params.append(('targetType', target_type))
        if target_product is not None:
            _form_params.append(('targetProduct', target_product))
        if target_trig_price is not None:
            _form_params.append(('targetTrigPrice', target_trig_price))
        if target_qty is not None:
            _form_params.append(('targetQty', target_qty))
        if target_price is not None:
            _form_params.append(('targetPrice', target_price))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/oms/modify-order/oco',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pending_gtt_orders(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PendingGTTOrders200Response:
        """GTT OrderBook

        to get the list of pending gtt, oco orders orders

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pending_gtt_orders_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PendingGTTOrders200Response",
            '401': "PendingGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pending_gtt_orders_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PendingGTTOrders200Response]:
        """GTT OrderBook

        to get the list of pending gtt, oco orders orders

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pending_gtt_orders_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PendingGTTOrders200Response",
            '401': "PendingGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pending_gtt_orders_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """GTT OrderBook

        to get the list of pending gtt, oco orders orders

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pending_gtt_orders_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PendingGTTOrders200Response",
            '401': "PendingGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pending_gtt_orders_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/oms/orders/gtt',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place_bracket_order(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        target_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        trailing_stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Trailing stop loss price.")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlaceBracketOrder200Response:
        """Place Bracket Order

        to place the bracket order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param target_price: Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field (required)
        :type target_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param trailing_stop_price: Trailing stop loss price.
        :type trailing_stop_price: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_bracket_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            stop_trig_price=stop_trig_price,
            target_price=target_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            trailing_stop_price=trailing_stop_price,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceBracketOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_bracket_order_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        target_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        trailing_stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Trailing stop loss price.")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlaceBracketOrder200Response]:
        """Place Bracket Order

        to place the bracket order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param target_price: Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field (required)
        :type target_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param trailing_stop_price: Trailing stop loss price.
        :type trailing_stop_price: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_bracket_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            stop_trig_price=stop_trig_price,
            target_price=target_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            trailing_stop_price=trailing_stop_price,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceBracketOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_bracket_order_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        target_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        trailing_stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Trailing stop loss price.")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Place Bracket Order

        to place the bracket order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param target_price: Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is '2400' and if you want to set the target or profit order price for 2500 then pass the difference '100' in this field (required)
        :type target_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param trailing_stop_price: Trailing stop loss price.
        :type trailing_stop_price: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_bracket_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            stop_trig_price=stop_trig_price,
            target_price=target_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            trailing_stop_price=trailing_stop_price,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceBracketOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_bracket_order_serialize(
        self,
        sym_id,
        qty,
        side,
        type,
        stop_trig_price,
        target_price,
        limit_price,
        trig_price,
        mkt_prot,
        trailing_stop_price,
        remarks,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if qty is not None:
            _form_params.append(('qty', qty))
        if side is not None:
            _form_params.append(('side', side))
        if type is not None:
            _form_params.append(('type', type))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if mkt_prot is not None:
            _form_params.append(('mktProt', mkt_prot))
        if stop_trig_price is not None:
            _form_params.append(('stopTrigPrice', stop_trig_price))
        if target_price is not None:
            _form_params.append(('targetPrice', target_price))
        if trailing_stop_price is not None:
            _form_params.append(('trailingStopPrice', trailing_stop_price))
        if remarks is not None:
            _form_params.append(('remarks', remarks))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/place-order/bo',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place_cover_order(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlaceBracketOrder200Response:
        """Place Cover Order

        to place the cover order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_cover_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            stop_trig_price=stop_trig_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceBracketOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_cover_order_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlaceBracketOrder200Response]:
        """Place Cover Order

        to place the cover order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_cover_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            stop_trig_price=stop_trig_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceBracketOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_cover_order_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        side: Annotated[StrictStr, Field(description="Order side 'buy' or 'sell'")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field. ")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Main leg order price. Required only for 'limit' and 'stoplimit' orders")] = None,
        trig_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'stoplimit'")] = None,
        mkt_prot: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is applicable only for the main leg order and required only if the order type is 'market'")] = None,
        remarks: Annotated[Optional[StrictStr], Field(description="Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Place Cover Order

        to place the cover order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param side: Order side 'buy' or 'sell' (required)
        :type side: str
        :param type: Price type of an order (required)
        :type type: str
        :param stop_trig_price: Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is '2400' and if you want to set the stop loss trigger at '2300' then pass the difference '100' in this field.  (required)
        :type stop_trig_price: float
        :param limit_price: Main leg order price. Required only for 'limit' and 'stoplimit' orders
        :type limit_price: float
        :param trig_price: This is applicable only for the main leg order and required only if the order type is 'stoplimit'
        :type trig_price: float
        :param mkt_prot: This is applicable only for the main leg order and required only if the order type is 'market'
        :type mkt_prot: float
        :param remarks: Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
        :type remarks: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_cover_order_serialize(
            sym_id=sym_id,
            qty=qty,
            side=side,
            type=type,
            stop_trig_price=stop_trig_price,
            limit_price=limit_price,
            trig_price=trig_price,
            mkt_prot=mkt_prot,
            remarks=remarks,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceBracketOrder200Response",
            '400': "PlaceOrderResponse",
            '401': "PlaceOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_cover_order_serialize(
        self,
        sym_id,
        qty,
        side,
        type,
        stop_trig_price,
        limit_price,
        trig_price,
        mkt_prot,
        remarks,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if qty is not None:
            _form_params.append(('qty', qty))
        if side is not None:
            _form_params.append(('side', side))
        if type is not None:
            _form_params.append(('type', type))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if mkt_prot is not None:
            _form_params.append(('mktProt', mkt_prot))
        if stop_trig_price is not None:
            _form_params.append(('stopTrigPrice', stop_trig_price))
        if remarks is not None:
            _form_params.append(('remarks', remarks))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/place-order/co',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place_gtt_order(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        trig_price_per: Annotated[Union[StrictFloat, StrictInt], Field(description="Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.")],
        trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlaceGTTOrder200Response:
        """Place GTT Order

        Place good till triggered order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param type: Price type of an order (required)
        :type type: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param trig_price_per: Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP. (required)
        :type trig_price_per: float
        :param trig_price: Trigger price with respect to LTP (required)
        :type trig_price: float
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_gtt_order_serialize(
            sym_id=sym_id,
            type=type,
            side=side,
            product=product,
            trig_price_per=trig_price_per,
            trig_price=trig_price,
            qty=qty,
            limit_price=limit_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceGTTOrder200Response",
            '401': "PlaceGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_gtt_order_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        trig_price_per: Annotated[Union[StrictFloat, StrictInt], Field(description="Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.")],
        trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlaceGTTOrder200Response]:
        """Place GTT Order

        Place good till triggered order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param type: Price type of an order (required)
        :type type: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param trig_price_per: Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP. (required)
        :type trig_price_per: float
        :param trig_price: Trigger price with respect to LTP (required)
        :type trig_price: float
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_gtt_order_serialize(
            sym_id=sym_id,
            type=type,
            side=side,
            product=product,
            trig_price_per=trig_price_per,
            trig_price=trig_price,
            qty=qty,
            limit_price=limit_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceGTTOrder200Response",
            '401': "PlaceGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_gtt_order_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        type: Annotated[StrictStr, Field(description="Price type of an order")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        trig_price_per: Annotated[Union[StrictFloat, StrictInt], Field(description="Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.")],
        trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Place GTT Order

        Place good till triggered order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param type: Price type of an order (required)
        :type type: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type product: str
        :param trig_price_per: Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP. (required)
        :type trig_price_per: float
        :param trig_price: Trigger price with respect to LTP (required)
        :type trig_price: float
        :param qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type qty: float
        :param limit_price: This is required only for limit and stop limit orders
        :type limit_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_gtt_order_serialize(
            sym_id=sym_id,
            type=type,
            side=side,
            product=product,
            trig_price_per=trig_price_per,
            trig_price=trig_price,
            qty=qty,
            limit_price=limit_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceGTTOrder200Response",
            '401': "PlaceGTTOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_gtt_order_serialize(
        self,
        sym_id,
        type,
        side,
        product,
        trig_price_per,
        trig_price,
        qty,
        limit_price,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if type is not None:
            _form_params.append(('type', type))
        if side is not None:
            _form_params.append(('side', side))
        if product is not None:
            _form_params.append(('product', product))
        if trig_price_per is not None:
            _form_params.append(('trigPricePer', trig_price_per))
        if trig_price is not None:
            _form_params.append(('trigPrice', trig_price))
        if qty is not None:
            _form_params.append(('qty', qty))
        if limit_price is not None:
            _form_params.append(('limitPrice', limit_price))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/place-order/gtt',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place_oco_order(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        stop_loss_type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_loss_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        stop_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        target_type: Annotated[StrictStr, Field(description="Price type of an order")],
        target_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        target_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        target_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        target_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlaceOCOOrder200Response:
        """Place OCO Order

        Place A one-cancels-the-other order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param stop_loss_type: Price type of an order (required)
        :type stop_loss_type: str
        :param stop_loss_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type stop_loss_product: str
        :param stop_trig_price: Trigger price with respect to LTP (required)
        :type stop_trig_price: float
        :param stop_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type stop_qty: float
        :param target_type: Price type of an order (required)
        :type target_type: str
        :param target_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type target_product: str
        :param target_trig_price: Trigger price with respect to LTP (required)
        :type target_trig_price: float
        :param target_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type target_qty: float
        :param stop_price: This is required only for limit and stop limit orders
        :type stop_price: float
        :param target_price: This is required only for limit and stop limit orders
        :type target_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_oco_order_serialize(
            sym_id=sym_id,
            side=side,
            stop_loss_type=stop_loss_type,
            stop_loss_product=stop_loss_product,
            stop_trig_price=stop_trig_price,
            stop_qty=stop_qty,
            target_type=target_type,
            target_product=target_product,
            target_trig_price=target_trig_price,
            target_qty=target_qty,
            stop_price=stop_price,
            target_price=target_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceOCOOrder200Response",
            '401': "PlaceOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_oco_order_with_http_info(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        stop_loss_type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_loss_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        stop_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        target_type: Annotated[StrictStr, Field(description="Price type of an order")],
        target_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        target_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        target_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        target_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlaceOCOOrder200Response]:
        """Place OCO Order

        Place A one-cancels-the-other order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param stop_loss_type: Price type of an order (required)
        :type stop_loss_type: str
        :param stop_loss_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type stop_loss_product: str
        :param stop_trig_price: Trigger price with respect to LTP (required)
        :type stop_trig_price: float
        :param stop_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type stop_qty: float
        :param target_type: Price type of an order (required)
        :type target_type: str
        :param target_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type target_product: str
        :param target_trig_price: Trigger price with respect to LTP (required)
        :type target_trig_price: float
        :param target_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type target_qty: float
        :param stop_price: This is required only for limit and stop limit orders
        :type stop_price: float
        :param target_price: This is required only for limit and stop limit orders
        :type target_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_oco_order_serialize(
            sym_id=sym_id,
            side=side,
            stop_loss_type=stop_loss_type,
            stop_loss_product=stop_loss_product,
            stop_trig_price=stop_trig_price,
            stop_qty=stop_qty,
            target_type=target_type,
            target_product=target_product,
            target_trig_price=target_trig_price,
            target_qty=target_qty,
            stop_price=stop_price,
            target_price=target_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceOCOOrder200Response",
            '401': "PlaceOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_oco_order_without_preload_content(
        self,
        sym_id: Annotated[StrictStr, Field(description="Unique identifier of the symbol")],
        side: Annotated[StrictStr, Field(description="Order id of an order. This will be received in orders response")],
        stop_loss_type: Annotated[StrictStr, Field(description="Price type of an order")],
        stop_loss_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        stop_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        stop_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        target_type: Annotated[StrictStr, Field(description="Price type of an order")],
        target_product: Annotated[StrictStr, Field(description="Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives")],
        target_trig_price: Annotated[Union[StrictFloat, StrictInt], Field(description="Trigger price with respect to LTP")],
        target_qty: Annotated[Union[StrictFloat, StrictInt], Field(description="No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.")],
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        target_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This is required only for limit and stop limit orders")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Place OCO Order

        Place A one-cancels-the-other order

        :param sym_id: Unique identifier of the symbol (required)
        :type sym_id: str
        :param side: Order id of an order. This will be received in orders response (required)
        :type side: str
        :param stop_loss_type: Price type of an order (required)
        :type stop_loss_type: str
        :param stop_loss_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type stop_loss_product: str
        :param stop_trig_price: Trigger price with respect to LTP (required)
        :type stop_trig_price: float
        :param stop_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type stop_qty: float
        :param target_type: Price type of an order (required)
        :type target_type: str
        :param target_product: Product type of an order. 'delivery' is applicable for equities. 'normal' is applicable for derivatives. 'intraday' is applicable for both equity and derivatives (required)
        :type target_product: str
        :param target_trig_price: Trigger price with respect to LTP (required)
        :type target_trig_price: float
        :param target_qty: No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50. (required)
        :type target_qty: float
        :param stop_price: This is required only for limit and stop limit orders
        :type stop_price: float
        :param target_price: This is required only for limit and stop limit orders
        :type target_price: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_oco_order_serialize(
            sym_id=sym_id,
            side=side,
            stop_loss_type=stop_loss_type,
            stop_loss_product=stop_loss_product,
            stop_trig_price=stop_trig_price,
            stop_qty=stop_qty,
            target_type=target_type,
            target_product=target_product,
            target_trig_price=target_trig_price,
            target_qty=target_qty,
            stop_price=stop_price,
            target_price=target_price,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlaceOCOOrder200Response",
            '401': "PlaceOCOOrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_oco_order_serialize(
        self,
        sym_id,
        side,
        stop_loss_type,
        stop_loss_product,
        stop_trig_price,
        stop_qty,
        target_type,
        target_product,
        target_trig_price,
        target_qty,
        stop_price,
        target_price,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if sym_id is not None:
            _form_params.append(('symId', sym_id))
        if side is not None:
            _form_params.append(('side', side))
        if stop_loss_type is not None:
            _form_params.append(('stopLossType', stop_loss_type))
        if stop_loss_product is not None:
            _form_params.append(('stopLossProduct', stop_loss_product))
        if stop_trig_price is not None:
            _form_params.append(('stopTrigPrice', stop_trig_price))
        if stop_qty is not None:
            _form_params.append(('stopQty', stop_qty))
        if stop_price is not None:
            _form_params.append(('stopPrice', stop_price))
        if target_type is not None:
            _form_params.append(('targetType', target_type))
        if target_product is not None:
            _form_params.append(('targetProduct', target_product))
        if target_trig_price is not None:
            _form_params.append(('targetTrigPrice', target_trig_price))
        if target_qty is not None:
            _form_params.append(('targetQty', target_qty))
        if target_price is not None:
            _form_params.append(('targetPrice', target_price))
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'http_bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/oms/place-order/oco',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


